package bh.multianim;

/**
 * Wrapper for multiple named h2d.Object elements in macro-generated code.
 * Implements `IUpdatable` â€” the same interface as the runtime `Updatable`,
 * providing a unified API regardless of builder vs macro path.
 *
 * Generated by `ProgrammableCodeGen` when multiple elements share the same `#name`.
 */
class ProgrammableUpdatable implements IUpdatable {
	public final objects:Array<h2d.Object>;
	var lastObject:Null<h2d.Object> = null;

	public function new(objects:Array<h2d.Object>) {
		this.objects = objects;
	}

	public function setVisibility(visible:Bool) {
		for (obj in objects)
			obj.visible = visible;
	}

	public function updateText(newText:String, throwIfAnyFails:Bool = true) {
		for (obj in objects) {
			if (Std.isOfType(obj, h2d.Text)) {
				(cast obj : h2d.Text).text = newText;
			} else if (throwIfAnyFails) {
				throw 'invalid updateText: expected h2d.Text but got ${Type.getClassName(Type.getClass(obj))}';
			}
		}
	}

	public function updateTile(newTile:h2d.Tile, throwIfAnyFails:Bool = true) {
		for (obj in objects) {
			if (Std.isOfType(obj, h2d.Bitmap)) {
				(cast obj : h2d.Bitmap).tile = newTile;
			} else if (throwIfAnyFails) {
				throw 'invalid updateTile: expected h2d.Bitmap but got ${Type.getClassName(Type.getClass(obj))}';
			}
		}
	}

	public function setObject(newObject:h2d.Object) {
		if (objects.length != 1)
			throw 'setObject needs exactly one element';
		if (lastObject == newObject)
			return;

		if (lastObject != null) {
			lastObject.remove();
			lastObject = null;
		}

		objects[0].addChild(newObject);
		lastObject = newObject;
	}

	public function addObject(newObject:h2d.Object) {
		if (objects.length != 1)
			throw 'addObject needs exactly one element';

		objects[0].addChild(newObject);
		lastObject = newObject;
	}

	public function clearObjects() {
		for (obj in objects) {
			obj.removeChildren();
		}
		lastObject = null;
	}
}
